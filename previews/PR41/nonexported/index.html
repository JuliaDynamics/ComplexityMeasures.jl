<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-exported · Entropies.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Entropies.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Entropies.jl</a></li><li><span class="tocitem">Estimators</span><ul><li><a class="tocitem" href="../CountOccurrences/">CountOccurrences (counting)</a></li><li><a class="tocitem" href="../VisitationFrequency/">Visitation frequency (binning)</a></li><li><a class="tocitem" href="../Permutation/">Permutation (symbolic)</a></li><li><a class="tocitem" href="../NearestNeighbors/">Nearest neighbor estimators</a></li><li><a class="tocitem" href="../NaiveKernel/">Kernel density</a></li><li><a class="tocitem" href="../TimeScaleMODWT/">Time-scale (wavelet)</a></li></ul></li><li class="is-active"><a class="tocitem" href>Non-exported</a><ul class="internal"><li><a class="tocitem" href="#Symbolization"><span>Symbolization</span></a></li><li><a class="tocitem" href="#Binning-related"><span>Binning-related</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Non-exported</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-exported</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Entropies.jl/blob/master/docs/src/nonexported.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Non-exported-functions"><a class="docs-heading-anchor" href="#Non-exported-functions">Non-exported functions</a><a id="Non-exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Non-exported-functions" title="Permalink"></a></h1><h2 id="Symbolization"><a class="docs-heading-anchor" href="#Symbolization">Symbolization</a><a id="Symbolization-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Entropies.symbolize" href="#Entropies.symbolize"><code>Entropies.symbolize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symbolize(x::AbstractVector{T}, est::SymbolicPermutation) where {T} → Vector{Int}
symbolize!(s, x::AbstractVector{T}, est::SymbolicPermutation) where {T} → Vector{Int}</code></pre><p>If <code>x</code> is a univariate time series, first <code>x</code> create a delay reconstruction of <code>x</code> using embedding lag <code>est.τ</code> and embedding dimension <code>est.m</code>, then symbolizing the resulting  state vectors with <a href="#Entropies.encode_motif"><code>encode_motif</code></a>. </p><p>Optionally, the in-place <code>symbolize!</code> can be used to put symbols in a pre-allocated  integer vector <code>s</code>, where <code>length(s) == length(x)-(est.m-1)*est.τ</code>.</p><pre><code class="language-none">symbolize(x::AbstractDataset{m, T}, est::SymbolicPermutation) where {m, T} → Vector{Int}
symbolize!(s, x::AbstractDataset{m, T}, est::SymbolicPermutation) where {m, T} → Vector{Int}</code></pre><p>If <code>x</code> is an <code>m</code>-dimensional dataset, then motif lengths are determined by the dimension of  the input data, and <code>x</code> is symbolized by converting each <code>m</code>-dimensional  state vector as a unique integer in the range <span>$1, 2, \ldots, m-1$</span>, using  <a href="#Entropies.encode_motif"><code>encode_motif</code></a>. </p><p>Optionally, the in-place <code>symbolize!</code> can be used to put symbols in a pre-allocated  integer vector <code>s</code>, where <code>length(s) == length(s)</code>.</p><p><strong>Examples</strong></p><p>Symbolize a 7-dimensional dataset. Motif lengths (or order of the permutations) are  inferred to be 7.</p><pre><code class="language-julia">using DelayEmbeddings, Entropies
D = Dataset([rand(7) for i = 1:1000])
s = symbolize(D, SymbolicPermutation())</code></pre><p>Symbolize a univariate time series by first embedding it in dimension 5 with embedding lag 2. Motif lengths (or order of the permutations) are therefore 5.</p><pre><code class="language-julia">using DelayEmbeddings, Entropies
n = 5000
x = rand(n)
s = symbolize(x, SymbolicPermutation(m = 5, τ = 2))</code></pre><p>The integer vector <code>s</code> now has length <code>n-(m-1)*τ = 4992</code>, and each <code>s[i]</code> contains  the integer symbol for the ordinal pattern of state vector <code>x[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/603bd0852510d45243152debab9011fa0da8deac/src/symbolic/SymbolicPermutation.jl#L244-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Entropies.encode_motif" href="#Entropies.encode_motif"><code>Entropies.encode_motif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode_motif(x, m::Int = length(x)) → s::Int</code></pre><p>Encode the length-<code>m</code> motif <code>x</code> (a vector of indices that would sort some vector <code>v</code>  in ascending order) into its unique integer symbol <span>$s \in \{1, 2, \ldots, m - 1 \}$</span>,  using Algorithm 1 in Berger et al. (2019)<sup class="footnote-reference"><a id="citeref-Berger2019" href="#footnote-Berger2019">[Berger2019]</a></sup>. </p><p><strong>Example</strong></p><pre><code class="language-julia">v = rand(5)

# The indices that would sort `v` in ascending order. This is now a permutation 
# of the index permutation (1, 2, ..., 5)
x = sortperm(v)

# Encode this permutation as an integer.
encode_motif(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/603bd0852510d45243152debab9011fa0da8deac/src/symbolic/utils.jl#L1-L22">source</a></section></article><h2 id="Binning-related"><a class="docs-heading-anchor" href="#Binning-related">Binning-related</a><a id="Binning-related-1"></a><a class="docs-heading-anchor-permalink" href="#Binning-related" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Entropies.encode_as_bin" href="#Entropies.encode_as_bin"><code>Entropies.encode_as_bin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode_as_bin(point, reference_point, edgelengths) → Vector{Int}</code></pre><p>Encode a point into its integer bin labels relative to some <code>reference_point</code> (always counting from lowest to highest magnitudes), given a set of box  <code>edgelengths</code> (one for each axis). The first bin on the positive side of  the reference point is indexed with 0, and the first bin on the negative  side of the reference point is indexed with -1.</p><p>See also: <a href="#Entropies.joint_visits"><code>joint_visits</code></a>, <a href="#Entropies.marginal_visits"><code>marginal_visits</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Entropies

refpoint = [0, 0, 0]
steps = [0.2, 0.2, 0.3]
encode_as_bin(rand(3), refpoint, steps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/603bd0852510d45243152debab9011fa0da8deac/src/binning_based/rectangular/count_box_visits.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Entropies.joint_visits" href="#Entropies.joint_visits"><code>Entropies.joint_visits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">joint_visits(points, binning_scheme::RectangularBinning) → Vector{Vector{Int}}</code></pre><p>Determine which bins are visited by <code>points</code> given the rectangular binning scheme <code>ϵ</code>. Bins are referenced relative to the axis minima, and are  encoded as integers, such that each box in the binning is assigned a unique integer array (one element for each dimension). </p><p>For example, if a bin is visited three times, then the corresponding  integer array will appear three times in the array returned.</p><p>See also: <a href="#Entropies.marginal_visits"><code>marginal_visits</code></a>, <a href="#Entropies.encode_as_bin"><code>encode_as_bin</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using DelayEmbeddings, Entropies

pts = Dataset([rand(5) for i = 1:100]);
joint_visits(pts, RectangularBinning(0.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/603bd0852510d45243152debab9011fa0da8deac/src/binning_based/rectangular/count_box_visits.jl#L48-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Entropies.marginal_visits" href="#Entropies.marginal_visits"><code>Entropies.marginal_visits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">marginal_visits(points, binning_scheme::RectangularBinning, dims) → Vector{Vector{Int}}</code></pre><p>Determine which bins are visited by <code>points</code> given the rectangular binning scheme <code>ϵ</code>, but only along the desired dimensions <code>dims</code>. Bins are referenced  relative to the axis minima, and are encoded as integers, such that each box  in the binning is assigned a unique integer array (one element for each  dimension in <code>dims</code>). </p><p>For example, if a bin is visited three times, then the corresponding  integer array will appear three times in the array returned.</p><p>See also: <a href="#Entropies.joint_visits"><code>joint_visits</code></a>, <a href="#Entropies.encode_as_bin"><code>encode_as_bin</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using DelayEmbeddings, Entropies
pts = Dataset([rand(5) for i = 1:100]);

# Marginal visits along dimension 3 and 5
marginal_visits(pts, RectangularBinning(0.3), [3, 5])

# Marginal visits along dimension 2 through 5
marginal_visits(pts, RectangularBinning(0.3), 2:5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/603bd0852510d45243152debab9011fa0da8deac/src/binning_based/rectangular/count_box_visits.jl#L76-L102">source</a></section><section><div><pre><code class="language-none">marginal_visits(joint_visits, dims) → Vector{Vector{Int}}</code></pre><p>If joint visits have been precomputed using <a href="#Entropies.joint_visits"><code>joint_visits</code></a>, marginal  visits can be returned directly without providing the binning again  using the <code>marginal_visits(joint_visits, dims)</code> signature.</p><p>See also: <a href="#Entropies.joint_visits"><code>joint_visits</code></a>, <a href="#Entropies.encode_as_bin"><code>encode_as_bin</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">using DelayEmbeddings, Entropies
pts = Dataset([rand(5) for i = 1:100]);

# First compute joint visits, then marginal visits along dimensions 1 and 4
jv = joint_visits(pts, RectangularBinning(0.2))
marginal_visits(jv, [1, 4])

# Marginals along dimension 2
marginal_visits(jv, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/603bd0852510d45243152debab9011fa0da8deac/src/binning_based/rectangular/count_box_visits.jl#L117-L139">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Berger2019"><a class="tag is-link" href="#citeref-Berger2019">Berger2019</a>Berger, Sebastian, et al. &quot;Teaching Ordinal Patterns to a Computer: Efficient Encoding Algorithms Based on the Lehmer Code.&quot; Entropy 21.10 (2019): 1023.</li><li class="footnote" id="footnote-Berger2019"><a class="tag is-link" href="#citeref-Berger2019">Berger2019</a>Berger, Sebastian, et al. &quot;Teaching Ordinal Patterns to a Computer: Efficient Encoding Algorithms Based on the Lehmer Code.&quot; Entropy 21.10 (2019): 1023.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TimeScaleMODWT/">« Time-scale (wavelet)</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 November 2020 22:45">Tuesday 24 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
