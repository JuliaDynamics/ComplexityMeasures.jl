<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Permutation (symbolic) · Entropies.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Entropies.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Entropies.jl</a></li><li><span class="tocitem">Estimators</span><ul><li><a class="tocitem" href="../CountOccurrences/">CountOccurrences (counting)</a></li><li><a class="tocitem" href="../VisitationFrequency/">Visitation frequency (binning)</a></li><li class="is-active"><a class="tocitem" href>Permutation (symbolic)</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Utility-methods"><span>Utility methods</span></a></li></ul></li><li><a class="tocitem" href="../SymbolicWeightedPermutation/">Weighted permutation (symbolic)</a></li><li><a class="tocitem" href="../SymbolicAmplitudeAwarePermutation/">Amplitude-aware permutation (symbolic)</a></li><li><a class="tocitem" href="../NearestNeighbors/">Nearest neighbor estimators</a></li><li><a class="tocitem" href="../NaiveKernel/">Kernel density</a></li><li><a class="tocitem" href="../TimeScaleMODWT/">Time-scale (wavelet)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Estimators</a></li><li class="is-active"><a href>Permutation (symbolic)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Permutation (symbolic)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Entropies.jl/blob/master/docs/src/SymbolicPermutation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Permutation-(symbolic)"><a class="docs-heading-anchor" href="#Permutation-(symbolic)">Permutation (symbolic)</a><a id="Permutation-(symbolic)-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-(symbolic)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Entropies.SymbolicPermutation" href="#Entropies.SymbolicPermutation"><code>Entropies.SymbolicPermutation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SymbolicPermutation(; τ = 1, m = 3) &lt;: PermutationProbabilityEstimator</code></pre><p>A symbolic, permutation based probabilities/entropy estimator. </p><p><strong>Properties of original signal preserved</strong></p><p>Permutations of a signal preserve ordinal patterns (sorting information). This implementation is based on Bandt &amp; Pompe et al. (2002)<sup class="footnote-reference"><a id="citeref-BandtPompe2002" href="#footnote-BandtPompe2002">[BandtPompe2002]</a></sup> and  Berger et al. (2019) <sup class="footnote-reference"><a id="citeref-Berger2019" href="#footnote-Berger2019">[Berger2019]</a></sup>.</p><p><strong>Estimation</strong></p><p><strong>Univariate time series</strong></p><p>To estimate probabilities or entropies from univariate time series, use the following methods:</p><ul><li><code>probabilities(x::AbstractVector, est::SymbolicPermutation)</code>. Constructs state vectors    from <code>x</code> using embedding lag <code>τ</code> and embedding dimension <code>m</code>. The ordinal patterns of the    state vectors are then symbolized, and probabilities are taken as the relative    frequency of symbols.</li><li><code>genentropy(x::AbstractVector, est::SymbolicPermutation; α=1, base = 2)</code> computes   probabilities by calling <code>probabilities(x::AbstractVector, est::SymbolicPermutation)</code>,   then computer the order-<code>α</code> generalized entropy to the given base.</li></ul><p>See below for in-place versions below allow you to provide a pre-allocated symbol array <code>s</code> for faster repeated computations of input data of the same length.</p><div class="admonition is-info"><header class="admonition-header">Default embedding dimension and embedding lag</header><div class="admonition-body"><p>By default, embedding dimension <span>$m = 3$</span> with embedding lag <span>$\tau = 1$</span> is used when embedding a time series for symbolization. You should probably make a more informed decision about embedding parameters when computing the permutation entropy of a real time series. In all cases, <span>$m$</span> must be at least 2 (there are no permutations of a single-element state vector, so need <span>$m \geq 2$</span>).</p></div></div><p><strong>Multivariate datasets</strong></p><p>Although not dealt with in the original Bandt &amp; Pompe (2002) paper, numerically speaking,  permutation entropy can also be computed for multivariate datasets with dimension ≥ 2. Such datasets may be, for example, preembedded time series. Then, just skip the delay  reconstruction step, compute and symbols directly from the <span>$L$</span> existing state vectors  <span>$\{\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x_L}\}$</span>.</p><ul><li><code>probabilities(x::Dataset, est::SymbolicPermutation)</code>. Compute ordinal patterns of the    state vectors of <code>x</code> directly (without doing any embedding), symbolize those patterns,   and compute probabilities as relative frequencies of symbols.</li><li><code>genentropy(x::Dataset, est::SymbolicPermutation)</code>. Computes probabilities from    symbol frequencies using <code>probabilities(x::Dataset, est::SymbolicPermutation)</code>,   then computes the order-<code>α</code> generalized (permutation) entropy to the given base.</li></ul><div class="admonition is-category-warn"><header class="admonition-header">Dynamical interpretation</header><div class="admonition-body"><p>A dynamical interpretation of the permutation entropy does not necessarily hold if computing it on generic multivariate datasets. Method signatures for <code>Dataset</code>s are provided for convenience, and should only be applied if you understand the relation between your input data, the numerical value for the permutation entropy, and its interpretation.</p></div></div><p><strong>Speeding up repeated computations</strong></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>A pre-allocated integer symbol array <code>s</code> can be provided to save some memory  allocations if the probabilities are to be computed for multiple data sets.</p><p><em>Note: it is not the array that will hold the final probabilities that is pre-allocated, but the temporary integer array containing the symbolized data points. Thus, if provided, it is required that <code>length(x) == length(s)</code> if <code>x</code> is a Dataset, or <code>length(s) == length(x) - (m-1)τ</code> if <code>x</code> is a univariate signal that is to be embedded first</em>.</p><p>Use the following signatures.</p><pre><code class="language-julia">probabilities!(s::Vector{Int}, x::AbstractVector, est::SymbolicPermutation) → ps::Probabilities
probabilities!(s::Vector{Int}, x::AbstractDataset, est::SymbolicPermutation) → ps::Probabilities</code></pre></div></div><p><strong>Description</strong></p><p><strong>Embedding, ordinal patterns and symbolization</strong></p><p>Consider the <span>$n$</span>-element univariate time series <span>$\{x(t) = x_1, x_2, \ldots, x_n\}$</span>. Let <span>$\mathbf{x_i}^{m, \tau} = \{x_j, x_{j+\tau}, \ldots, x_{j+(m-1)\tau}\}$</span> for <span>$j = 1, 2, \ldots n - (m-1)\tau$</span> be the <span>$i$</span>-th state vector in a delay reconstruction with embedding dimension <span>$m$</span> and reconstruction lag <span>$\tau$</span>. There are then <span>$N = n - (m-1)\tau$</span> state vectors.</p><p>For an <span>$m$</span>-dimensional vector, there are <span>$m!$</span> possible ways of sorting it in ascending order of magnitude. Each such possible sorting ordering is called a <em>motif</em>. Let <span>$\pi_i^{m, \tau}$</span> denote the motif associated with the <span>$m$</span>-dimensional state vector <span>$\mathbf{x_i}^{m, \tau}$</span>, and let <span>$R$</span> be the number of distinct motifs that can be constructed from the <span>$N$</span> state vectors. Then there are at most <span>$R$</span> motifs; <span>$R = N$</span> precisely when all motifs are unique, and <span>$R = 1$</span> when all motifs are the same.</p><p>Each unique motif <span>$\pi_i^{m, \tau}$</span> can be mapped to a unique integer symbol <span>$0 \leq s_i \leq M!-1$</span>. Let <span>$S(\pi) : \mathbb{R}^m \to \mathbb{N}_0$</span> be the function that maps the motif <span>$\pi$</span> to its symbol <span>$s$</span>, and let <span>$\Pi$</span> denote the set of symbols <span>$\Pi = \{ s_i \}_{i\in \{ 1, \ldots, R\}}$</span>.</p><p><strong>Probability computation</strong></p><p>The probability of a given motif is its frequency of occurrence, normalized by the total number of motifs (with notation from <sup class="footnote-reference"><a id="citeref-Fadlallah2013" href="#footnote-Fadlallah2013">[Fadlallah2013]</a></sup>),</p><div>\[p(\pi_i^{m, \tau}) = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i} \left(\mathbf{x}_k^{m, \tau} \right) }{\sum_{k=1}^N \mathbf{1}_{u:S(u) \in \Pi} \left(\mathbf{x}_k^{m, \tau} \right)} = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i} \left(\mathbf{x}_k^{m, \tau} \right) }{N},\]</div><p>where the function <span>$\mathbf{1}_A(u)$</span> is the indicator function of a set <span>$A$</span>. That     is, <span>$\mathbf{1}_A(u) = 1$</span> if <span>$u \in A$</span>, and <span>$\mathbf{1}_A(u) = 0$</span> otherwise.</p><p><strong>Entropy computation</strong></p><p>The generalized order-<code>α</code> Renyi entropy<sup class="footnote-reference"><a id="citeref-Rényi1960" href="#footnote-Rényi1960">[Rényi1960]</a></sup> can be computed over the probability  distribution of symbols as  <span>$H(m, \tau, \alpha) = \dfrac{\alpha}{1-\alpha} \log  \left( \sum_{j=1}^R p_j^\alpha \right)$</span>. Permutation entropy, as described in  Bandt and Pompe (2002), is just the limiting case as <span>$α \to1$</span>, that is <span>$H(m, \tau) = - \sum_j^R p(\pi_j^{m, \tau}) \ln p(\pi_j^{m, \tau})$</span>.</p><div class="admonition is-category-hint"><header class="admonition-header">Generalized entropy order vs. permutation order</header><div class="admonition-body"><p>Do not confuse the order of the generalized entropy (<code>α</code>) with the order <code>m</code> of the permutation entropy (<code>m</code>, which controls the symbol size). Permutation entropy is usually estimated with <code>α = 1</code>, but the implementation here allows the generalized entropy of any dimension to be computed from the symbol frequency distribution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/265c76be276b5c72b5858dfbfea702599645650f/src/symbolic/SymbolicPermutation.jl#L9-L147">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>This example reproduces an example from Bandt and Pompe (2002), where the permutation entropy is compared with the largest Lyapunov exponents from time series of the chaotic  logistic map. Entropy estimates using <a href="../SymbolicWeightedPermutation/#Entropies.SymbolicWeightedPermutation"><code>SymbolicWeightedPermutation</code></a> and <a href="../SymbolicAmplitudeAwarePermutation/#Entropies.SymbolicAmplitudeAwarePermutation"><code>SymbolicAmplitudeAwarePermutation</code></a> are added here for comparison.</p><pre><code class="language-julia">using DynamicalSystems, PyPlot, Entropies

ds = Systems.logistic()
rs = 3.4:0.001:4
N_lyap, N_ent = 100000, 10000
m, τ = 6, 1 # Symbol size/dimension and embedding lag

# Generate one time series for each value of the logistic parameter r
lyaps = Float64[]
hs_perm = Float64[]
hs_wtperm = Float64[]
hs_ampperm = Float64[]

base = Base.MathConstants.e
for r in rs
    ds.p[1] = r
    push!(lyaps, lyapunov(ds, N_lyap))

    x = trajectory(ds, N_ent) # time series
    hperm = Entropies.genentropy(x, SymbolicPermutation(m = m, τ = τ), base = base)
    hwtperm = Entropies.genentropy(x, SymbolicWeightedPermutation(m = m, τ = τ), base = base)
    hampperm = Entropies.genentropy(x, SymbolicAmplitudeAwarePermutation(m = m, τ = τ), base = base)

    push!(hs_perm, hperm); push!(hs_wtperm, hwtperm); push!(hs_ampperm, hampperm)
end

f = figure(figsize = (6, 8))
a1 = subplot(411)
plot(rs, lyaps); ylim(-2, log(2)); ylabel(&quot;\$\\lambda\$&quot;)
a1.axes.get_xaxis().set_ticklabels([])
xlim(rs[1], rs[end]);

a2 = subplot(412)
plot(rs, hs_perm; color = &quot;C2&quot;); xlim(rs[1], rs[end]);
xlabel(&quot;&quot;); ylabel(&quot;\$h_6 (SP)\$&quot;)

a3 = subplot(413)
plot(rs, hs_wtperm; color = &quot;C3&quot;); xlim(rs[1], rs[end]);
xlabel(&quot;&quot;); ylabel(&quot;\$h_6 (SWP)\$&quot;)

a4 = subplot(414)
plot(rs, hs_ampperm; color = &quot;C4&quot;); xlim(rs[1], rs[end]);
xlabel(&quot;\$r\$&quot;); ylabel(&quot;\$h_6 (SAAP)\$&quot;)
tight_layout()
savefig(&quot;permentropy.png&quot;)</code></pre><p><img src="../permentropy.png" alt/></p><h2 id="Utility-methods"><a class="docs-heading-anchor" href="#Utility-methods">Utility methods</a><a id="Utility-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-methods" title="Permalink"></a></h2><p>Some convenience functions for symbolization are provided.</p><article class="docstring"><header><a class="docstring-binding" id="Entropies.symbolize" href="#Entropies.symbolize"><code>Entropies.symbolize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symbolize(x::AbstractVector{T}, est::SymbolicPermutation) where {T} → Vector{Int}
symbolize!(s, x::AbstractVector{T}, est::SymbolicPermutation) where {T} → Vector{Int}</code></pre><p>If <code>x</code> is a univariate time series, first <code>x</code> create a delay reconstruction of <code>x</code> using embedding lag <code>est.τ</code> and embedding dimension <code>est.m</code>, then symbolizing the resulting  state vectors with <a href="#Entropies.encode_motif"><code>encode_motif</code></a>. </p><p>Optionally, the in-place <code>symbolize!</code> can be used to put symbols in a pre-allocated  integer vector <code>s</code>, where <code>length(s) == length(x)-(est.m-1)*est.τ</code>.</p><pre><code class="language-none">symbolize(x::AbstractDataset{m, T}, est::SymbolicPermutation) where {m, T} → Vector{Int}
symbolize!(s, x::AbstractDataset{m, T}, est::SymbolicPermutation) where {m, T} → Vector{Int}</code></pre><p>If <code>x</code> is an <code>m</code>-dimensional dataset, then motif lengths are determined by the dimension of  the input data, and <code>x</code> is symbolized by converting each <code>m</code>-dimensional  state vector as a unique integer in the range <span>$1, 2, \ldots, m-1$</span>, using  <a href="#Entropies.encode_motif"><code>encode_motif</code></a>. </p><p>Optionally, the in-place <code>symbolize!</code> can be used to put symbols in a pre-allocated  integer vector <code>s</code>, where <code>length(s) == length(s)</code>.</p><p><strong>Examples</strong></p><p>Symbolize a 7-dimensional dataset. Motif lengths (or order of the permutations) are  inferred to be 7.</p><pre><code class="language-julia">using DelayEmbeddings, Entropies
D = Dataset([rand(7) for i = 1:1000])
s = symbolize(D, SymbolicPermutation())</code></pre><p>Symbolize a univariate time series by first embedding it in dimension 5 with embedding lag 2. Motif lengths (or order of the permutations) are therefore 5.</p><pre><code class="language-julia">using DelayEmbeddings, Entropies
n = 5000
x = rand(n)
s = symbolize(x, SymbolicPermutation(m = 5, τ = 2))</code></pre><p>The integer vector <code>s</code> now has length <code>n-(m-1)*τ = 4992</code>, and each <code>s[i]</code> contains  the integer symbol for the ordinal pattern of state vector <code>x[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/265c76be276b5c72b5858dfbfea702599645650f/src/symbolic/SymbolicPermutation.jl#L157-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Entropies.encode_motif" href="#Entropies.encode_motif"><code>Entropies.encode_motif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode_motif(x, m::Int = length(x)) → s::Int</code></pre><p>Encode the length-<code>m</code> motif <code>x</code> (a vector of indices that would sort some vector <code>v</code>  in ascending order) into its unique integer symbol <span>$s \in \{1, 2, \ldots, m - 1 \}$</span>,  using Algorithm 1 in Berger et al. (2019)<sup class="footnote-reference"><a id="citeref-Berger2019" href="#footnote-Berger2019">[Berger2019]</a></sup>. </p><p><strong>Example</strong></p><pre><code class="language-julia">v = rand(5)

# The indices that would sort `v` in ascending order. This is now a permutation 
# of the index permutation (1, 2, ..., 5)
x = sortperm(v)

# Encode this permutation as an integer.
encode_motif(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/265c76be276b5c72b5858dfbfea702599645650f/src/symbolic/utils.jl#L3-L24">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-BandtPompe2002"><a class="tag is-link" href="#citeref-BandtPompe2002">BandtPompe2002</a>Bandt, Christoph, and Bernd Pompe. &quot;Permutation entropy: a natural complexity measure for time series.&quot; Physical review letters 88.17 (2002): 174102.</li><li class="footnote" id="footnote-Berger2019"><a class="tag is-link" href="#citeref-Berger2019">Berger2019</a>Berger, Sebastian, et al. &quot;Teaching Ordinal Patterns to a Computer: Efficient Encoding Algorithms Based on the Lehmer Code.&quot; Entropy 21.10 (2019): 1023.</li><li class="footnote" id="footnote-Fadlallah2013"><a class="tag is-link" href="#citeref-Fadlallah2013">Fadlallah2013</a>Fadlallah, Bilal, et al. &quot;Weighted-permutation entropy: A complexity measure for time series incorporating amplitude information.&quot; Physical Review E 87.2 (2013): 022911.</li><li class="footnote" id="footnote-Rényi1960"><a class="tag is-link" href="#citeref-Rényi1960">Rényi1960</a>A. Rényi, <em>Proceedings of the fourth Berkeley Symposium on Mathematics, Statistics and Probability</em>, pp 547 (1960)</li><li class="footnote" id="footnote-Berger2019"><a class="tag is-link" href="#citeref-Berger2019">Berger2019</a>Berger, Sebastian, et al. &quot;Teaching Ordinal Patterns to a Computer: Efficient Encoding Algorithms Based on the Lehmer Code.&quot; Entropy 21.10 (2019): 1023.</li><li class="footnote" id="footnote-Berger2019"><a class="tag is-link" href="#citeref-Berger2019">Berger2019</a>Berger, Sebastian, et al. &quot;Teaching Ordinal Patterns to a Computer: Efficient Encoding Algorithms Based on the Lehmer Code.&quot; Entropy 21.10 (2019): 1023.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../VisitationFrequency/">« Visitation frequency (binning)</a><a class="docs-footer-nextpage" href="../SymbolicWeightedPermutation/">Weighted permutation (symbolic) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 18 November 2020 00:16">Wednesday 18 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
