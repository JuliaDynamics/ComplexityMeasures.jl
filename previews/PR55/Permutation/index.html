<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Permutation (symbolic) · Entropies.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Entropies.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Entropies.jl</a></li><li><span class="tocitem">Estimators</span><ul><li><a class="tocitem" href="../CountOccurrences/">CountOccurrences (counting)</a></li><li><a class="tocitem" href="../VisitationFrequency/">Visitation frequency (binning)</a></li><li><a class="tocitem" href="../TransferOperator/">Transfer operator (binning)</a></li><li class="is-active"><a class="tocitem" href>Permutation (symbolic)</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../NearestNeighbors/">Nearest neighbor estimators</a></li><li><a class="tocitem" href="../NaiveKernel/">Kernel density</a></li><li><a class="tocitem" href="../TimeScaleMODWT/">Time-scale (wavelet)</a></li></ul></li><li><a class="tocitem" href="../nonexported/">Non-exported</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Estimators</a></li><li class="is-active"><a href>Permutation (symbolic)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Permutation (symbolic)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Entropies.jl/blob/master/docs/src/Permutation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Permutation-(symbolic)"><a class="docs-heading-anchor" href="#Permutation-(symbolic)">Permutation (symbolic)</a><a id="Permutation-(symbolic)-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-(symbolic)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Entropies.SymbolicPermutation" href="#Entropies.SymbolicPermutation"><code>Entropies.SymbolicPermutation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SymbolicPermutation(; τ = 1, m = 3, lt = Entropies.isless_rand) &lt;: ProbabilityEstimator
SymbolicWeightedPermutation(; τ = 1, m = 3, lt = Entropies.isless_rand) &lt;: ProbabilityEstimator
SymbolicAmplitudeAwarePermutation(; τ = 1, m = 3, A = 0.5, lt = Entropies.isless_rand) &lt;: ProbabilityEstimator</code></pre><p>Symbolic, permutation-based probabilities/entropy estimators.</p><p>Uses embedding dimension <span>$m = 3$</span> with embedding lag <span>$\tau = 1$</span> by default. The minimum dimension <span>$m$</span> is 2 (there are no sorting permutations of single-element state vectors).</p><p><strong>Repeated values during symbolization</strong></p><p>In the original implementation of permutation entropy <sup class="footnote-reference"><a id="citeref-BandtPompe2002" href="#footnote-BandtPompe2002">[BandtPompe2002]</a></sup>, equal values are ordered after their order of appearance, but this can lead to erroneous temporal correlations, especially for data with low-amplitude resolution <sup class="footnote-reference"><a id="citeref-Zunino2017" href="#footnote-Zunino2017">[Zunino2017]</a></sup>. Here, we resolve this issue by letting the user provide a custom &quot;less-than&quot; function. The keyword <code>lt</code> accepts a function that decides which of two state vector elements are smaller. If two elements are equal, the default behaviour is to randomly assign one of them as the largest (<code>lt = Entropies.isless_rand</code>). For data with low amplitude resolution, computing probabilities multiple times using the random approach may reduce these erroneous effects.</p><p>To get the behaviour described in Bandt and Pompe (2002), use <code>lt = Base.isless</code>).</p><p><strong>Properties of original signal preserved</strong></p><ul><li><strong><code>SymbolicPermutation</code></strong>: Preserves ordinal patterns of state vectors (sorting information). This   implementation is based on Bandt &amp; Pompe et al. (2002)<sup class="footnote-reference"><a id="citeref-BandtPompe2002" href="#footnote-BandtPompe2002">[BandtPompe2002]</a></sup> and   Berger et al. (2019) <sup class="footnote-reference"><a id="citeref-Berger2019" href="#footnote-Berger2019">[Berger2019]</a></sup>.</li><li><strong><code>SymbolicWeightedPermutation</code></strong>: Like <code>SymbolicPermutation</code>, but also encodes amplitude   information by tracking the variance of the state vectors. This implementation is based   on Fadlallah et al. (2013)<sup class="footnote-reference"><a id="citeref-Fadlallah2013" href="#footnote-Fadlallah2013">[Fadlallah2013]</a></sup>.</li><li><strong><code>SymbolicAmplitudeAwarePermutation</code></strong>: Like <code>SymbolicPermutation</code>, but also encodes   amplitude information by considering a weighted combination of <em>absolute amplitudes</em>   of state vectors, and <em>relative differences between elements</em> of state vectors. See   description below for explanation of the weighting parameter <code>A</code>. This implementation   is based on Azami &amp; Escudero (2016) <sup class="footnote-reference"><a id="citeref-Azami2016" href="#footnote-Azami2016">[Azami2016]</a></sup>.</li></ul><p><strong>Probability estimation</strong></p><p><strong>Univariate time series</strong></p><p>To estimate probabilities or entropies from univariate time series, use the following methods:</p><ul><li><code>probabilities(x::AbstractVector, est::SymbolicProbabilityEstimator)</code>. Constructs state vectors   from <code>x</code> using embedding lag <code>τ</code> and embedding dimension <code>m</code>, symbolizes state vectors,   and computes probabilities as (weighted) relative frequency of symbols.</li><li><code>genentropy(x::AbstractVector, est::SymbolicProbabilityEstimator; α=1, base = 2)</code> computes   probabilities by calling <code>probabilities(x::AbstractVector, est)</code>,   then computer the order-<code>α</code> generalized entropy to the given base.</li></ul><p><strong>Speeding up repeated computations</strong></p><p>A pre-allocated integer symbol array <code>s</code> can be provided to save some memory allocations if the probabilities are to be computed for multiple data sets.</p><p><em>Note: it is not the array that will hold the final probabilities that is pre-allocated, but the temporary integer array containing the symbolized data points. Thus, if provided, it is required that <code>length(x) == length(s)</code> if <code>x</code> is a Dataset, or <code>length(s) == length(x) - (m-1)τ</code> if <code>x</code> is a univariate signal that is to be embedded first</em>.</p><p>Use the following signatures (only works for <code>SymbolicPermutation</code>).</p><pre><code class="language-julia">probabilities!(s::Vector{Int}, x::AbstractVector, est::SymbolicPermutation) → ps::Probabilities
probabilities!(s::Vector{Int}, x::AbstractDataset, est::SymbolicPermutation) → ps::Probabilities</code></pre><p><strong>Multivariate datasets</strong></p><p>Although not dealt with in the original paper describing the estimators, numerically speaking, permutation entropies can also be computed for multivariate datasets with dimension ≥ 2 (but see caveat below). Such datasets may be, for example, preembedded time series. Then, just skip the delay reconstruction step, compute and symbols directly from the <span>$L$</span> existing state vectors <span>$\{\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x_L}\}$</span>.</p><ul><li><code>probabilities(x::AbstractDataset, est::SymbolicProbabilityEstimator)</code>. Compute ordinal patterns of the   state vectors of <code>x</code> directly (without doing any embedding), symbolize those patterns,   and compute probabilities as (weighted) relative frequencies of symbols.</li><li><code>genentropy(x::AbstractDataset, est::SymbolicProbabilityEstimator)</code>. Computes probabilities from   symbol frequencies using <code>probabilities(x::AbstractDataset, est::SymbolicProbabilityEstimator)</code>,   then computes the order-<code>α</code> generalized (permutation) entropy to the given base.</li></ul><p><em>Caveat: A dynamical interpretation of the permutation entropy does not necessarily hold if computing it on generic multivariate datasets. Method signatures for <code>Dataset</code>s are provided for convenience, and should only be applied if you understand the relation between your input data, the numerical value for the permutation entropy, and its interpretation.</em></p><p><strong>Description</strong></p><p>All symbolic estimators use the same underlying approach to estimating probabilities.</p><p><strong>Embedding, ordinal patterns and symbolization</strong></p><p>Consider the <span>$n$</span>-element univariate time series <span>$\{x(t) = x_1, x_2, \ldots, x_n\}$</span>. Let <span>$\mathbf{x_i}^{m, \tau} = \{x_j, x_{j+\tau}, \ldots, x_{j+(m-1)\tau}\}$</span> for <span>$j = 1, 2, \ldots n - (m-1)\tau$</span> be the <span>$i$</span>-th state vector in a delay reconstruction with embedding dimension <span>$m$</span> and reconstruction lag <span>$\tau$</span>. There are then <span>$N = n - (m-1)\tau$</span> state vectors.</p><p>For an <span>$m$</span>-dimensional vector, there are <span>$m!$</span> possible ways of sorting it in ascending order of magnitude. Each such possible sorting ordering is called a <em>motif</em>. Let <span>$\pi_i^{m, \tau}$</span> denote the motif associated with the <span>$m$</span>-dimensional state vector <span>$\mathbf{x_i}^{m, \tau}$</span>, and let <span>$R$</span> be the number of distinct motifs that can be constructed from the <span>$N$</span> state vectors. Then there are at most <span>$R$</span> motifs; <span>$R = N$</span> precisely when all motifs are unique, and <span>$R = 1$</span> when all motifs are the same.</p><p>Each unique motif <span>$\pi_i^{m, \tau}$</span> can be mapped to a unique integer symbol <span>$0 \leq s_i \leq M!-1$</span>. Let <span>$S(\pi) : \mathbb{R}^m \to \mathbb{N}_0$</span> be the function that maps the motif <span>$\pi$</span> to its symbol <span>$s$</span>, and let <span>$\Pi$</span> denote the set of symbols <span>$\Pi = \{ s_i \}_{i\in \{ 1, \ldots, R\}}$</span>.</p><p><strong>Probability computation</strong></p><p><strong><code>SymbolicPermutation</code></strong></p><p>The probability of a given motif is its frequency of occurrence, normalized by the total number of motifs (with notation from <sup class="footnote-reference"><a id="citeref-Fadlallah2013" href="#footnote-Fadlallah2013">[Fadlallah2013]</a></sup>),</p><p class="math-container">\[p(\pi_i^{m, \tau}) = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i} \left(\mathbf{x}_k^{m, \tau} \right) }{\sum_{k=1}^N \mathbf{1}_{u:S(u) \in \Pi} \left(\mathbf{x}_k^{m, \tau} \right)} = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i} \left(\mathbf{x}_k^{m, \tau} \right) }{N},\]</p><p>where the function <span>$\mathbf{1}_A(u)$</span> is the indicator function of a set <span>$A$</span>. That     is, <span>$\mathbf{1}_A(u) = 1$</span> if <span>$u \in A$</span>, and <span>$\mathbf{1}_A(u) = 0$</span> otherwise.</p><p><strong><code>SymbolicAmplitudeAwarePermutation</code></strong></p><p>Amplitude-aware permutation entropy is computed analogously to regular permutation entropy but probabilities are weighted by amplitude information as follows.</p><p class="math-container">\[p(\pi_i^{m, \tau}) = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i} \left( \mathbf{x}_k^{m, \tau} \right) \, a_k}{\sum_{k=1}^N \mathbf{1}_{u:S(u) \in \Pi} \left( \mathbf{x}_k^{m, \tau} \right) \,a_k} = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i} \left( \mathbf{x}_k^{m, \tau} \right) \, a_k}{\sum_{k=1}^N a_k}.\]</p><p>The weights encoding amplitude information about state vector <span>$\mathbf{x}_i = (x_1^i, x_2^i, \ldots, x_m^i)$</span> are</p><p class="math-container">\[a_i = \dfrac{A}{m} \sum_{k=1}^m |x_k^i | + \dfrac{1-A}{d-1} \sum_{k=2}^d |x_{k}^i - x_{k-1}^i|,\]</p><p>with <span>$0 \leq A \leq 1$</span>. When <span>$A=0$</span> , only internal differences between the elements of <span>$\mathbf{x}_i$</span> are weighted. Only mean amplitude of the state vector elements are weighted when <span>$A=1$</span>. With, <span>$0&lt;A&lt;1$</span>, a combined weighting is used.</p><p><strong><code>SymbolicWeightedPermutation</code></strong></p><p>Weighted permutation entropy is also computed analogously to regular permutation entropy, but adds weights that encode amplitude information too:</p><p class="math-container">\[p(\pi_i^{m, \tau}) = \dfrac{\sum_{k=1}^N \mathbf{1}_{u:S(u) = s_i}
\left( \mathbf{x}_k^{m, \tau} \right)
\, w_k}{\sum_{k=1}^N \mathbf{1}_{u:S(u) \in \Pi}
\left( \mathbf{x}_k^{m, \tau} \right) \,w_k} = \dfrac{\sum_{k=1}^N
\mathbf{1}_{u:S(u) = s_i}
\left( \mathbf{x}_k^{m, \tau} \right) \, w_k}{\sum_{k=1}^N w_k}.\]</p><p>The weighted permutation entropy is equivalent to regular permutation entropy when weights are positive and identical (<span>$w_j = \beta \,\,\, \forall \,\,\, j \leq N$</span> and <span>$\beta &gt; 0)$</span>. Weights are dictated by the variance of the state vectors.</p><p>Let the aritmetic mean of state vector <span>$\mathbf{x}_i$</span> be denoted by</p><p class="math-container">\[\mathbf{\hat{x}}_j^{m, \tau} = \frac{1}{m} \sum_{k=1}^m x_{j + (k+1)\tau}.\]</p><p>Weights are then computed as</p><p class="math-container">\[w_j = \dfrac{1}{m}\sum_{k=1}^m (x_{j+(k+1)\tau} - \mathbf{\hat{x}}_j^{m, \tau})^2.\]</p><p><em>Note: in equation 7, section III, of the original paper, the authors write</em></p><p class="math-container">\[w_j = \dfrac{1}{m}\sum_{k=1}^m (x_{j-(k-1)\tau} - \mathbf{\hat{x}}_j^{m, \tau})^2.\]</p><p><em>But given the formula they give for the arithmetic mean, this is <strong>not</strong> the variance of <span>$\mathbf{x}_i$</span>, because the indices are mixed: <span>$x_{j+(k-1)\tau}$</span> in the weights formula, vs. <span>$x_{j+(k+1)\tau}$</span> in the arithmetic mean formula. This seems to imply that amplitude information about previous delay vectors are mixed with mean amplitude information about current vectors. The authors also mix the terms &quot;vector&quot; and &quot;neighboring vector&quot; (but uses the same notation for both), making it hard to interpret whether the sign switch is a typo or intended. Here, we use the notation above, which actually computes the variance for <span>$\mathbf{x}_i$</span></em>.</p><p><strong>Entropy computation</strong></p><p>The generalized order-<code>α</code> Renyi entropy<sup class="footnote-reference"><a id="citeref-Rényi1960" href="#footnote-Rényi1960">[Rényi1960]</a></sup> can be computed over the probability distribution of symbols as <span>$H(m, \tau, \alpha) = \dfrac{\alpha}{1-\alpha} \log \left( \sum_{j=1}^R p_j^\alpha \right)$</span>. Permutation entropy, as described in Bandt and Pompe (2002), is just the limiting case as <span>$α \to1$</span>, that is <span>$H(m, \tau) = - \sum_j^R p(\pi_j^{m, \tau}) \ln p(\pi_j^{m, \tau})$</span>.</p><p><em>Note: Do not confuse the order of the generalized entropy (<code>α</code>) with the order <code>m</code> of the permutation entropy (which controls the symbol size). Permutation entropy is usually estimated with <code>α = 1</code>, but the implementation here allows the generalized entropy of any dimension to be computed from the symbol frequency distribution.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Entropies.jl/blob/3f77ca8720ac86fda1e44e3f4db529f0cd111e85/src/symbolic/SymbolicPermutation.jl#L8-L233">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>This example reproduces an example from Bandt and Pompe (2002), where the permutation entropy is compared with the largest Lyapunov exponents from time series of the chaotic logistic map. Entropy estimates using <a href="@ref"><code>SymbolicWeightedPermutation</code></a> and <a href="@ref"><code>SymbolicAmplitudeAwarePermutation</code></a> are added here for comparison.</p><pre><code class="language-julia">using Entropies, DynamicalSystems, PyPlot

ds = Systems.logistic()
rs = 3.4:0.001:4
N_lyap, N_ent = 100000, 10000
m, τ = 6, 1 # Symbol size/dimension and embedding lag

# Generate one time series for each value of the logistic parameter r
lyaps = Float64[]
hs_perm = Float64[]
hs_wtperm = Float64[]
hs_ampperm = Float64[]

base = Base.MathConstants.e

# Original paper doesn&#39;t use random assignment for ties, here: sort after order of occurrence
lt = Base.isless
est = SymbolicPermutation(m = m, τ = τ, lt = lt)
est_aa = SymbolicAmplitudeAwarePermutation(m = m, τ = τ, lt = lt)
est_wt = SymbolicWeightedPermutation(m = m, τ = τ, lt = lt)

for r in rs
    ds.p[1] = r
    push!(lyaps, lyapunov(ds, N_lyap))

    x = trajectory(ds, N_ent) # time series
    hperm = Entropies.genentropy(x, est, base = base)
    hampperm = Entropies.genentropy(x, est_aa, base = base)
    hwtperm = Entropies.genentropy(x, SymbolicWeightedPermutation(m = m, τ = τ), base = base)
    push!(hs_perm, hperm); push!(hs_ampperm, hampperm); push!(hs_wtperm, hwtperm);
end

f = figure(figsize = (6, 8))
a1 = subplot(411)
plot(rs, lyaps); ylim(-2, log(2)); ylabel(&quot;\$\\lambda\$&quot;)
a1.axes.get_xaxis().set_ticklabels([])
xlim(rs[1], rs[end]);

a2 = subplot(412)
plot(rs, hs_perm; color = &quot;C2&quot;); xlim(rs[1], rs[end]);
xlabel(&quot;&quot;); ylabel(&quot;\$h_6 (SP)\$&quot;)

a3 = subplot(413)
plot(rs, hs_wtperm; color = &quot;C3&quot;); xlim(rs[1], rs[end]);
xlabel(&quot;&quot;); ylabel(&quot;\$h_6 (SWP)\$&quot;)

a4 = subplot(414)
plot(rs, hs_ampperm; color = &quot;C4&quot;); xlim(rs[1], rs[end]);
xlabel(&quot;\$r\$&quot;); ylabel(&quot;\$h_6 (SAAP)\$&quot;)
tight_layout()
savefig(&quot;permentropy.png&quot;)</code></pre><p><img src="../permentropy.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-BandtPompe2002"><a class="tag is-link" href="#citeref-BandtPompe2002">BandtPompe2002</a>Bandt, Christoph, and Bernd Pompe. &quot;Permutation entropy: a natural complexity measure for time series.&quot; Physical review letters 88.17 (2002): 174102.</li><li class="footnote" id="footnote-Berger2019"><a class="tag is-link" href="#citeref-Berger2019">Berger2019</a>Berger, Sebastian, et al. &quot;Teaching Ordinal Patterns to a Computer: Efficient Encoding Algorithms Based on the Lehmer Code.&quot; Entropy 21.10 (2019): 1023.</li><li class="footnote" id="footnote-Fadlallah2013"><a class="tag is-link" href="#citeref-Fadlallah2013">Fadlallah2013</a>Fadlallah, Bilal, et al. &quot;Weighted-permutation entropy: A complexity measure for time series incorporating amplitude information.&quot; Physical Review E 87.2 (2013): 022911.</li><li class="footnote" id="footnote-Rényi1960"><a class="tag is-link" href="#citeref-Rényi1960">Rényi1960</a>A. Rényi, <em>Proceedings of the fourth Berkeley Symposium on Mathematics, Statistics and Probability</em>, pp 547 (1960)</li><li class="footnote" id="footnote-Azami2016"><a class="tag is-link" href="#citeref-Azami2016">Azami2016</a>Azami, H., &amp; Escudero, J. (2016). Amplitude-aware permutation entropy: Illustration in spike detection and signal segmentation. Computer methods and programs in biomedicine, 128, 40-51.</li><li class="footnote" id="footnote-Fadlallah2013"><a class="tag is-link" href="#citeref-Fadlallah2013">Fadlallah2013</a>Fadlallah, Bilal, et al. &quot;Weighted-permutation entropy: A complexity measure for time series incorporating amplitude information.&quot; Physical Review E 87.2 (2013): 022911.</li><li class="footnote" id="footnote-Zunino2017"><a class="tag is-link" href="#citeref-Zunino2017">Zunino2017</a>Zunino, L., Olivares, F., Scholkmann, F., &amp; Rosso, O. A. (2017). Permutation entropy based time series analysis: Equalities in the input signal can lead to false conclusions. Physics Letters A, 381(22), 1883-1892.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TransferOperator/">« Transfer operator (binning)</a><a class="docs-footer-nextpage" href="../NearestNeighbors/">Nearest neighbor estimators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 21 February 2021 00:06">Sunday 21 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
