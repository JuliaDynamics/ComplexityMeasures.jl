<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Complexity measures · ComplexityMeasures.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ComplexityMeasures.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ComplexityMeasures.jl</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../probabilities/">Probabilities</a></li><li><a class="tocitem" href="../information_measures/">Information measures (entropies and co.)</a></li><li class="is-active"><a class="tocitem" href>Complexity measures</a><ul class="internal"><li><a class="tocitem" href="#Complexity-measures-API"><span>Complexity measures API</span></a></li><li><a class="tocitem" href="#Approximate-entropy"><span>Approximate entropy</span></a></li><li><a class="tocitem" href="#Sample-entropy"><span>Sample entropy</span></a></li><li><a class="tocitem" href="#Missing-dispersion-patterns"><span>Missing dispersion patterns</span></a></li><li><a class="tocitem" href="#Reverse-dispersion-entropy"><span>Reverse dispersion entropy</span></a></li><li><a class="tocitem" href="#Statistical-complexity"><span>Statistical complexity</span></a></li><li><a class="tocitem" href="#Lempel-Ziv-complexity"><span>Lempel-Ziv complexity</span></a></li></ul></li><li><a class="tocitem" href="../convenience/">Convenience functions</a></li><li><a class="tocitem" href="../examples/">ComplexityMeasures.jl Examples</a></li><li><a class="tocitem" href="../devdocs/">ComplexityMeasures.jl Dev Docs</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Complexity measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Complexity measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/main/docs/src/complexity.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Complexity-measures"><a class="docs-heading-anchor" href="#Complexity-measures">Complexity measures</a><a id="Complexity-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity-measures" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Be sure you have gone through the <a href="../tutorial/#Tutorial">Tutorial</a> before going through the API here to have a good idea of the terminology used in ComplexityMeasures.jl.</p></div></div><h2 id="Complexity-measures-API"><a class="docs-heading-anchor" href="#Complexity-measures-API">Complexity measures API</a><a id="Complexity-measures-API-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity-measures-API" title="Permalink"></a></h2><p>The complexity measure API is defined by the <a href="#ComplexityMeasures.complexity"><code>complexity</code></a> function, which may take as an input an <a href="#ComplexityMeasures.ComplexityEstimator"><code>ComplexityEstimator</code></a>. The function <a href="#ComplexityMeasures.complexity_normalized"><code>complexity_normalized</code></a> is also useful.</p><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.complexity" href="#ComplexityMeasures.complexity"><code>ComplexityMeasures.complexity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexity(c::ComplexityEstimator, x) → m::Real</code></pre><p>Estimate a complexity measure according to <code>c</code> for <a href="../#input_data">input data</a> <code>x</code>, where <code>c</code> is an instance of any subtype of <a href="#ComplexityMeasures.ComplexityEstimator"><code>ComplexityEstimator</code></a>:</p><ul><li><a href="#ComplexityMeasures.ApproximateEntropy"><code>ApproximateEntropy</code></a>.</li><li><a href="#ComplexityMeasures.LempelZiv76"><code>LempelZiv76</code></a>.</li><li><a href="#ComplexityMeasures.MissingDispersionPatterns"><code>MissingDispersionPatterns</code></a>.</li><li><a href="#ComplexityMeasures.ReverseDispersion"><code>ReverseDispersion</code></a>.</li><li><a href="#ComplexityMeasures.SampleEntropy"><code>SampleEntropy</code></a>.</li><li><a href="#ComplexityMeasures.StatisticalComplexity"><code>StatisticalComplexity</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/core/complexity.jl#L15-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.complexity_normalized" href="#ComplexityMeasures.complexity_normalized"><code>ComplexityMeasures.complexity_normalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexity_normalized(c::ComplexityEstimator, x) → m::Real ∈ [a, b]</code></pre><p>The same as <a href="#ComplexityMeasures.complexity"><code>complexity</code></a>, but the result is normalized to the interval <code>[a, b]</code>, where <code>[a, b]</code> depends on <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/core/complexity.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.ComplexityEstimator" href="#ComplexityMeasures.ComplexityEstimator"><code>ComplexityMeasures.ComplexityEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComplexityEstimator</code></pre><p>Supertype for estimators for various complexity measures that are not entropies in the strict mathematical sense.</p><p>See <a href="#ComplexityMeasures.complexity"><code>complexity</code></a> for all available estimators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/core/complexity.jl#L5-L12">source</a></section></article><h2 id="Approximate-entropy"><a class="docs-heading-anchor" href="#Approximate-entropy">Approximate entropy</a><a id="Approximate-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.ApproximateEntropy" href="#ComplexityMeasures.ApproximateEntropy"><code>ComplexityMeasures.ApproximateEntropy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximateEntropy &lt;: ComplexityEstimator
ApproximateEntropy([x]; r = 0.2std(x), kwargs...)</code></pre><p>An estimator for the approximate entropy <a href="../references/#Pincus1991">(Pincus, 1991)</a> complexity measure, used with <a href="#ComplexityMeasures.complexity"><code>complexity</code></a>.</p><p>The keyword argument <code>r</code> is mandatory if an input timeseries <code>x</code> is not provided.</p><p><strong>Keyword arguments</strong></p><ul><li><code>r::Real</code>: The radius used when querying for nearest neighbors around points. Its value   should be determined from the input data, for example as some proportion of the   standard deviation of the data.</li><li><code>m::Int = 2</code>: The embedding dimension.</li><li><code>τ::Int = 1</code>: The embedding lag.</li><li><code>base::Real = MathConstants.e</code>: The base to use for the logarithm. Pincus (1991) uses the   natural logarithm.</li></ul><p><strong>Description</strong></p><p>Approximate entropy (ApEn) is defined as</p><p class="math-container">\[ApEn(m ,r) = \lim_{N \to \infty} \left[ \phi(x, m, r) - \phi(x, m + 1, r) \right].\]</p><p>Approximate entropy is estimated for a timeseries <code>x</code>, by first embedding <code>x</code> using embedding dimension <code>m</code> and embedding lag <code>τ</code>, then searching for similar vectors within tolerance radius <code>r</code>, using the estimator described below, with logarithms to the given <code>base</code> (natural logarithm is used in Pincus, 1991).</p><p>Specifically, for a finite-length timeseries <code>x</code>, an estimator for <span>$ApEn(m ,r)$</span> is</p><p class="math-container">\[ApEn(m, r, N) = \phi(x, m, r, N) -  \phi(x, m + 1, r, N),\]</p><p>where <code>N = length(x)</code> and</p><p class="math-container">\[\phi(x, k, r, N) =
\dfrac{1}{N-(k-1)\tau} \sum_{i=1}^{N - (k-1)\tau}
\log{\left(
    \sum_{j = 1}^{N-(k-1)\tau} \dfrac{\theta(d({\bf x}_i^m, {\bf x}_j^m) \leq r)}{N-(k-1)\tau}
    \right)}.\]</p><p>Here, <span>$\theta(\cdot)$</span> returns 1 if the argument is true and 0 otherwise,  <span>$d({\bf x}_i, {\bf x}_j)$</span> returns the Chebyshev distance between vectors  <span>${\bf x}_i$</span> and <span>${\bf x}_j$</span>, and the <code>k</code>-dimensional embedding vectors are constructed from the input timeseries <span>$x(t)$</span> as</p><p class="math-container">\[{\bf x}_i^k = (x(i), x(i+τ), x(i+2τ), \ldots, x(i+(k-1)\tau)).\]</p><div class="admonition is-info"><header class="admonition-header">Flexible embedding lag</header><div class="admonition-body"><p>In the original paper, they fix <code>τ = 1</code>. In our implementation, the normalization constant is modified to account for embeddings with <code>τ != 1</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/approximate_entropy.jl#L8-L67">source</a></section></article><h2 id="Sample-entropy"><a class="docs-heading-anchor" href="#Sample-entropy">Sample entropy</a><a id="Sample-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.SampleEntropy" href="#ComplexityMeasures.SampleEntropy"><code>ComplexityMeasures.SampleEntropy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampleEntropy([x]; r = 0.2std(x), kwargs...) &lt;: ComplexityEstimator</code></pre><p>An estimator for the sample entropy complexity measure <a href="../references/#Richman2000">(Richman and Moorman, 2000)</a>, used with <a href="#ComplexityMeasures.complexity"><code>complexity</code></a> and <a href="#ComplexityMeasures.complexity_normalized"><code>complexity_normalized</code></a>.</p><p>The keyword argument <code>r</code> is mandatory if an input timeseries <code>x</code> is not provided.</p><p><strong>Keyword arguments</strong></p><ul><li><code>r::Real</code>: The radius used when querying for nearest neighbors around points. Its value   should be determined from the input data, for example as some proportion of the   standard deviation of the data.</li><li><code>m::Int = 1</code>: The embedding dimension.</li><li><code>τ::Int = 1</code>: The embedding lag.</li></ul><p><strong>Description</strong></p><p>An <em>estimator</em> for sample entropy using radius <code>r</code>, embedding dimension <code>m</code>, and embedding lag <code>τ</code> is</p><p class="math-container">\[SampEn(m,r, N) = -\ln{\dfrac{A(r, N)}{B(r, N)}}.\]</p><p>Here,</p><p class="math-container">\[\begin{aligned}
B(r, m, N) = \sum_{i = 1}^{N-m\tau} \sum_{j = 1, j \neq i}^{N-m\tau} \theta(d({\bf x}_i^m, {\bf x}_j^m) \leq r) \\
A(r, m, N) = \sum_{i = 1}^{N-m\tau} \sum_{j = 1, j \neq i}^{N-m\tau} \theta(d({\bf x}_i^{m+1}, {\bf x}_j^{m+1}) \leq r) \\
\end{aligned},\]</p><p>where <span>$\theta(\cdot)$</span> returns 1 if the argument is true and 0 otherwise, and <span>$d(x, y)$</span> computes the Chebyshev distance between <span>$x$</span> and <span>$y$</span>, and  <span>${\bf x}_i^{m}$</span> and <span>${\bf x}_i^{m+1}$</span> are <code>m</code>-dimensional and <code>m+1</code>-dimensional embedding vectors, where <code>k</code>-dimensional embedding vectors are constructed from the input timeseries <span>$x(t)$</span> as</p><p class="math-container">\[{\bf x}_i^k = (x(i), x(i+τ), x(i+2τ), \ldots, x(i+(k-1)\tau)).\]</p><p>Quoting Richman &amp; Moorman (2002): &quot;SampEn(m,r,N) will be defined except when B = 0, in which case no regularity has been detected, or when A = 0, which corresponds to a conditional probability of 0 and an infinite value of SampEn(m,r,N)&quot;. In these cases, <code>NaN</code> is returned.</p><p>If computing the normalized measure, then the resulting sample entropy is on <code>[0, 1]</code>.</p><div class="admonition is-info"><header class="admonition-header">Flexible embedding lag</header><div class="admonition-body"><p>The original algorithm fixes <code>τ = 1</code>. All formulas here are modified to account for any <code>τ</code>.</p></div></div><p>See also: <a href="../convenience/#ComplexityMeasures.entropy_sample"><code>entropy_sample</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/sample_entropy.jl#L9-L65">source</a></section></article><h2 id="Missing-dispersion-patterns"><a class="docs-heading-anchor" href="#Missing-dispersion-patterns">Missing dispersion patterns</a><a id="Missing-dispersion-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-dispersion-patterns" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.MissingDispersionPatterns" href="#ComplexityMeasures.MissingDispersionPatterns"><code>ComplexityMeasures.MissingDispersionPatterns</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MissingDispersionPatterns &lt;: ComplexityEstimator
MissingDispersionPatterns(est = Dispersion())</code></pre><p>An estimator for the number of missing dispersion patterns (<span>$N_{MDP}$</span>), a complexity measure which can be used to detect nonlinearity in time series <a href="../references/#Zhou2023">(Zhou <em>et al.</em>, 2023)</a>.</p><p>Used with <a href="#ComplexityMeasures.complexity"><code>complexity</code></a> or <a href="#ComplexityMeasures.complexity_normalized"><code>complexity_normalized</code></a>, whose implementation uses <a href="../probabilities/#ComplexityMeasures.missing_outcomes"><code>missing_outcomes</code></a>.</p><p><strong>Description</strong></p><p>If used with <a href="#ComplexityMeasures.complexity"><code>complexity</code></a>, <span>$N_{MDP}$</span> is computed by first symbolising each <code>xᵢ ∈ x</code>, then embedding the resulting symbol sequence using the dispersion pattern estimator <code>est</code>, and computing the quantity</p><p class="math-container">\[N_{MDP} = L - N_{ODP},\]</p><p>where <code>L = total_outcomes(est)</code> (i.e. the total number of possible dispersion patterns), and <span>$N_{ODP}$</span> is defined as the number of <em>occurring</em> dispersion patterns.</p><p>If used with <a href="#ComplexityMeasures.complexity_normalized"><code>complexity_normalized</code></a>, then <span>$N_{MDP}^N = (L - N_{ODP})/L$</span> is computed. The authors recommend that <code>total_outcomes(est.symbolization)^est.m &lt;&lt; length(x) - est.m*est.τ + 1</code> to avoid undersampling.</p><div class="admonition is-info"><header class="admonition-header">Encoding</header><div class="admonition-body"><p><a href="../probabilities/#ComplexityMeasures.Dispersion"><code>Dispersion</code></a>&#39;s linear mapping from CDFs to integers is based on equidistant partitioning of the interval <code>[0, 1]</code>. This is slightly different from Zhou et al. (2023)<a href="../references/#Zhou2023">Zhou2023</a>, which uses the linear mapping <span>$s_i := \text{round}(y + 0.5)$</span>.</p></div></div><p><strong>Usage</strong></p><p>In Zhou et al. (2023)<a href="../references/#Zhou2023">Zhou2023</a>, <a href="#ComplexityMeasures.MissingDispersionPatterns"><code>MissingDispersionPatterns</code></a> is used to detect nonlinearity in time series by comparing the <span>$N_{MDP}$</span> for a time series <code>x</code> to <span>$N_{MDP}$</span> values for an ensemble of surrogates of <code>x</code>. If <span>$N_{MDP} &gt; q_{MDP}^{WIAAFT}$</span>, where <span>$q_{MDP}^{WIAAFT}$</span> is some <code>q</code>-th quantile of the surrogate ensemble, then it is taken as evidence for nonlinearity.</p><p>See also: <a href="../probabilities/#ComplexityMeasures.Dispersion"><code>Dispersion</code></a>, <a href="#ComplexityMeasures.ReverseDispersion"><code>ReverseDispersion</code></a>, <a href="../probabilities/#ComplexityMeasures.total_outcomes"><code>total_outcomes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/missing_dispersion.jl#L7-L49">source</a></section></article><h2 id="Reverse-dispersion-entropy"><a class="docs-heading-anchor" href="#Reverse-dispersion-entropy">Reverse dispersion entropy</a><a id="Reverse-dispersion-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse-dispersion-entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.ReverseDispersion" href="#ComplexityMeasures.ReverseDispersion"><code>ComplexityMeasures.ReverseDispersion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReverseDispersion &lt;: ComplexityEstimator
ReverseDispersion(; c = 3, m = 2, τ = 1, check_unique = true)</code></pre><p>Estimator for the reverse dispersion entropy complexity measure <a href="../references/#Li2019">(Li <em>et al.</em>, 2019)</a>.</p><p><strong>Description</strong></p><p><a href="../references/#Li2019">Li <em>et al.</em> (2019)</a> defines the reverse dispersion entropy as</p><p class="math-container">\[H_{rde} = \sum_{i = 1}^{c^m} \left(p_i - \dfrac{1}{{c^m}} \right)^2 =
\left( \sum_{i=1}^{c^m} p_i^2 \right) - \dfrac{1}{c^{m}}\]</p><p>where the probabilities <span>$p_i$</span> are obtained precisely as for the <a href="../probabilities/#ComplexityMeasures.Dispersion"><code>Dispersion</code></a> probability estimator. Relative frequencies of dispersion patterns are computed using the given <code>encoding</code> scheme , which defaults to encoding using the normal cumulative distribution function (NCDF), as implemented by <a href="../probabilities/#ComplexityMeasures.GaussianCDFEncoding"><code>GaussianCDFEncoding</code></a>, using embedding dimension <code>m</code> and embedding delay <code>τ</code>. Recommended parameter values<a href="../references/#Li2018">(Li <em>et al.</em>, 2019)</a> are <code>m ∈ [2, 3]</code>, <code>τ = 1</code> for the embedding, and <code>c ∈ [3, 4, …, 8]</code> categories for the Gaussian mapping.</p><p>If normalizing, then the reverse dispersion entropy is normalized to <code>[0, 1]</code>.</p><p>The minimum value of <span>$H_{rde}$</span> is zero and occurs precisely when the dispersion pattern distribution is flat, which occurs when all <span>$p_i$</span>s are equal to <span>$1/c^m$</span>. Because <span>$H_{rde} \geq 0$</span>, <span>$H_{rde}$</span> can therefore be said to be a measure of how far the dispersion pattern probability distribution is from white noise.</p><p><strong>Data requirements</strong></p><p>The input must have more than one unique element for the default <a href="../probabilities/#ComplexityMeasures.GaussianCDFEncoding"><code>GaussianCDFEncoding</code></a> to be well-defined. <a href="../references/#Li2018">Li <em>et al.</em> (2019)</a> recommends that <code>x</code> has at least 1000 data points.</p><p>If <code>check_unique == true</code> (default), then it is checked that the input has more than one unique value. If <code>check_unique == false</code> and the input only has one unique element, then a <code>InexactError</code> is thrown when trying to compute probabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/reverse_dispersion_entropy.jl#L6-L44">source</a></section></article><h2 id="Statistical-complexity"><a class="docs-heading-anchor" href="#Statistical-complexity">Statistical complexity</a><a id="Statistical-complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-complexity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.StatisticalComplexity" href="#ComplexityMeasures.StatisticalComplexity"><code>ComplexityMeasures.StatisticalComplexity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StatisticalComplexity &lt;: ComplexityEstimator
StatisticalComplexity([x]; kwargs...)</code></pre><p>An estimator for the statistical complexity and entropy, originally by <a href="../references/#Rosso2007">(Rosso <em>et al.</em>, 2007)</a>, but here generalized see <a href="../references/#Rosso2013">Rosso <em>et al.</em> (2013)</a> to work with any <a href="../probabilities/#ComplexityMeasures.ProbabilitiesEstimator"><code>ProbabilitiesEstimator</code></a> in combination with any <a href="../probabilities/#ComplexityMeasures.OutcomeSpace"><code>OutcomeSpace</code></a> with a priori known <code>total_outcomes</code>, any valid distance metric, and any normalizable discrete information measure (e.g. entropies like <a href="../information_measures/#ComplexityMeasures.Shannon"><code>Shannon</code></a>, <a href="@ref, or extropies like [`ShannonExtropy`](@ref), the latter of which are not treated in Rosso et al.&#39;s papers"><code>Renyi</code></a>. Used with <a href="#ComplexityMeasures.complexity"><code>complexity</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>est::ProbabilitiesEstimator = RelativeAmount(OrdinalPatterns())</code>: The   <a href="../probabilities/#ComplexityMeasures.ProbabilitiesEstimator"><code>ProbabilitiesEstimator</code></a> used to estimate probabilities from the input data.   An <a href="../probabilities/#ComplexityMeasures.OutcomeSpace"><code>OutcomeSpace</code></a> must be given as the first argument to the estimator to   control how discretization within pixel windows is performed.</li><li><code>dist&lt;:SemiMetric = JSDivergence()</code>: The distance measure (from Distances.jl) to use for   estimating the distance between the estimated probability distribution and a uniform   distribution with the same maximal number of outcomes.</li><li><code>entr::InformationMeasure = Renyi()</code>: An   <a href="../information_measures/#ComplexityMeasures.InformationMeasure"><code>InformationMeasure</code></a> of choice. Any   information measure that defines <code>information_maximum</code> is valid here. Typically,   an entropy is used, e.g. <a href="../information_measures/#ComplexityMeasures.Shannon"><code>Shannon</code></a> or <a href="../information_measures/#ComplexityMeasures.Renyi"><code>Renyi</code></a> is used.</li></ul><p><strong>Description</strong></p><p>Statistical complexity is defined as</p><p class="math-container">\[C_q[P] = \mathcal{H}_q\cdot \mathcal{Q}_q[P],\]</p><p>where <span>$Q_q$</span> is a &quot;disequilibrium&quot; obtained from a distance-measure and <code>H_q</code> a disorder measure. In the original paper<a href="../references/#Rosso2007">(Rosso <em>et al.</em>, 2007)</a>, this complexity measure was defined via an ordinal pattern-based probability distribution, the Shannon entropy and the Jensen-Shannon divergence as a distance measure. This implementation allows for a generalization of the complexity measure as developed in <a href="../references/#Rosso2013">Rosso <em>et al.</em> (2013)</a>. Here, <span>$H_q$</span><code>can be the (q-order) Shannon-, Renyi or Tsallis entropy and</code><code>Q_q</code>` based either on the Euclidean, Wooters, Kullback, q-Kullback, Jensen or q-Jensen distance as</p><p class="math-container">\[Q_q[P] = Q_q^0\cdot D[P, P_e],\]</p><p>where <span>$D[P, P_e]$</span> is the distance between the obtained distribution <span>$P$</span> and a uniform distribution with the same maximum number of bins, measured by the distance measure <code>dist</code>.</p><p><strong>Usage</strong></p><p>The statistical complexity is exclusively used in combination with the related information measure (typically an entropy). <code>complexity(c::StatisticalComplexity, x)</code> returns only the statistical complexity.</p><p>The entropy (or other information measure) can be accessed as a <code>Ref</code> value of the struct as</p><pre><code class="language-julia hljs">x = randn(100)
c = StatisticalComplexity()
compl = complexity(c, x)
entr = c.entr_val[]</code></pre><p>To obtain both the entropy (or other information measure) and the statistical complexity together as a <code>Tuple</code>, use the wrapper <a href="#ComplexityMeasures.entropy_complexity"><code>entropy_complexity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/statistical_complexity.jl#L6-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.entropy_complexity" href="#ComplexityMeasures.entropy_complexity"><code>ComplexityMeasures.entropy_complexity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entropy_complexity(c::StatisticalComplexity, x)</code></pre><p>Return both the entropy and the corresponding <a href="#ComplexityMeasures.StatisticalComplexity"><code>StatisticalComplexity</code></a>. Useful when wanting to plot data on the &quot;entropy-complexity plane&quot;. See also <a href="#ComplexityMeasures.entropy_complexity_curves"><code>entropy_complexity_curves</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/statistical_complexity.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.entropy_complexity_curves" href="#ComplexityMeasures.entropy_complexity_curves"><code>ComplexityMeasures.entropy_complexity_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entropy_complexity_curves(c::StatisticalComplexity; num_max=1, num_min=1000) -&gt; (min_entropy_complexity, max_entropy_complexity)</code></pre><p>Calculate the maximum complexity-entropy curve for the statistical complexity according to <a href="../references/#Rosso2007">Rosso <em>et al.</em> (2007)</a> for <code>num_max * total_outcomes(c.est)</code> different values of the normalized information measure of choice (in case of the maximum complexity curves) and <code>num_min</code> different values of the normalized information measure of choice (in case of the minimum complexity curve).</p><p>This function can also be used to compute the maximum &quot;complexity-extropy curve&quot; if <code>c.entr</code> is an <a href="../information_measures/#ComplexityMeasures.InformationMeasure"><code>InformationMeasure</code></a>, which is the equivalent of the complexity-entropy curves, but using <a href="@ref"><code>extropy</code></a> instead of <a href="../information_measures/#ComplexityMeasures.information-Tuple{InformationMeasure, OutcomeSpace, Any}"><code>information</code></a>.</p><p><strong>Description</strong></p><p>The way the statistical complexity is designed, there is a minimum and maximum possible complexity for data with a given permutation entropy. The calculation time of the maximum complexity curve grows as <code>O(total_outcomes(c.est)^2)</code>, and thus takes very long for high numbers of outcomes. This function is inspired by S. Sippels implementation in statcomp <a href="../references/#Sippel2016">(Sippel <em>et al.</em>, 2016)</a>.</p><p>This function will work with any <code>ProbabilitiesEstimator</code> where <a href="../probabilities/#ComplexityMeasures.total_outcomes"><code>total_outcomes</code></a> is known a priori.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/statistical_complexity.jl#L128-L150">source</a></section></article><h2 id="Lempel-Ziv-complexity"><a class="docs-heading-anchor" href="#Lempel-Ziv-complexity">Lempel-Ziv complexity</a><a id="Lempel-Ziv-complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Lempel-Ziv-complexity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComplexityMeasures.LempelZiv76" href="#ComplexityMeasures.LempelZiv76"><code>ComplexityMeasures.LempelZiv76</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LempelZiv76 &lt;: ComplexityEstimator
LempelZiv76()</code></pre><p>The Lempel-Ziv, or <code>LempelZiv76</code>, complexity measure <a href="../references/#LempelZiv1976">(Lempel and Ziv, 1976)</a>, which is used with <a href="#ComplexityMeasures.complexity"><code>complexity</code></a> and <a href="#ComplexityMeasures.complexity_normalized"><code>complexity_normalized</code></a>.</p><p>For results to be comparable across sequences with different length, use the normalized version. Normalized <code>LempelZiv76</code>-complexity is implemented as given in <a href="../references/#Amigó2004">Amigó <em>et al.</em> (2004)</a>. The normalized measure is close to zero for very regular signals, while for random sequences, it is close to 1 with high probability<sup class="footnote-reference"><a id="citeref-Amigó2004" href="#footnote-Amigó2004">[Amigó2004]</a></sup>. Note: the normalized <code>LempelZiv76</code> complexity can be higher than 1<sup class="footnote-reference"><a id="citeref-Amigó2004" href="#footnote-Amigó2004">[Amigó2004]</a></sup>.</p><p>The <code>LempelZiv76</code> measure applies only to binary sequences, i.e. sequences with a two-element alphabet (precisely two distinct outcomes). For performance optimization, we do not check the number of unique elements in the input. If your input sequence is not binary, you must <a href="../probabilities/#ComplexityMeasures.encode"><code>encode</code></a> it first using one of the implemented <a href="../probabilities/#ComplexityMeasures.Encoding"><code>Encoding</code></a> schemes (or encode your data manually).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/b5df388f664ec99cb750df0b1a99ae87ee86d5ae/src/complexity_measures/lempel_ziv.jl#L3-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../information_measures/">« Information measures (entropies and co.)</a><a class="docs-footer-nextpage" href="../convenience/">Convenience functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 26 August 2023 11:36">Saturday 26 August 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
